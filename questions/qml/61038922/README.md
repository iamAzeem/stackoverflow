## QML (Qt/C++): Q_INVOKABLE const getter returns undefined, non-const getter returns correct value - why?

### C++ to QML: Return-by-value vs Return-by-reference (const/non-const)

Link: https://stackoverflow.com/questions/61038922/

## Question (Synopsis)

Why return by value works and by reference (const/non-const) doesn't?

### Example (method declarations)
```
Q_INVOKABLE       QString  SomeClass::get() const;  // Works! Returns QString
Q_INVOKABLE       QString& SomeClass::get() const;  // Fails! Returns undefined! Why?
Q_INVOKABLE const QString& SomeClass::get() const;  // Fails! Returns undefined! Why?
```
---

## Answer ([Test Project](qtquick-test))

[**Revision # 1**][1] (non-static/local data returning as const-reference):
```
const QString& CumulativeSalesZoneModel::getRiderTypeName( /*...*/ )
{
    QString result = QString();    // non-static/local object
    // ...
    return result;
}
```

On the C++ side, you are trying to return the address (reference) of a local variable i.e. `result`. It will go out of scope by the time that code block finishes its execution. So, you end up with a dangling reference. Using a dangling reference will result in [Undefined Behavior][2].

Check your compile logs. You must be getting a warning like this:

> warning: reference to stack memory associated with local variable 'result' returned

Here's a sample program reproducing this warning: https://godbolt.org/z/pZBq7H

---

**NOTE**: The following part regarding returning references also applies to Answer # 1 above once the code is on the Qt MOC / QML side.

[**Revision # 2**][3] (static data returning as const-reference):
```
const QString& CumulativeSalesZoneModel::getRiderTypeName( /*...*/ )
{
    static QString result = QString();    // static
    // ...
    return result;
}
```

According to the Qt [Meta Object Compiler][4] page, it states that (emphasis mine):

> **Signals and slots can have return types, but signals or slots returning references will be treated as returning void.**

And, to verify this, I've created this small [`test` project][5] with multiple public [Q_INVOKABLE][6] methods. The QML is pretty straightforward. The returning string is shown as the `title` of the window.

You need to observe the files generated by the MOC.

The generated `moc_test.cpp` contains this part:
```
static const uint qt_meta_data_Test[] = {

 // ... code removed for conciseness ...

 // methods: name, argc, parameters, tag, flags
       1,    0,   39,    2, 0x02 /* Public */,
       3,    0,   40,    2, 0x02 /* Public */,
       4,    0,   41,    2, 0x02 /* Public */,
       5,    0,   42,    2, 0x02 /* Public */,
       6,    0,   43,    2, 0x02 /* Public */,

 // methods: parameters
    QMetaType::QString,
    QMetaType::QString,
    QMetaType::QString,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};
```

As you can observe in the above code snippet (follow "methods" comments) that there are 5 methods. In the last portion, only the first 3 has return types i.e. `QString` but the last 2 return `void`.

And, observe the following generated method:
```
void Test::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Test *>(_o);
        Q_UNUSED(_t)
        switch (_id) {
        case 0: { QString _r = _t->get1_RetByValue_NonConstLocalString();
            if (_a[0]) *reinterpret_cast< QString*>(_a[0]) = std::move(_r); }  break;
        case 1: { QString _r = _t->get2_RetByConstValue_ConstLocalString();
            if (_a[0]) *reinterpret_cast< QString*>(_a[0]) = std::move(_r); }  break;
        case 2: { QString _r = _t->get3_RetByConstValue_StaticString();
            if (_a[0]) *reinterpret_cast< QString*>(_a[0]) = std::move(_r); }  break;
        case 3: _t->get4_RetByConstRef_LocalString(); break;
        case 4: _t->get5_RetByStaticConstRef_StaticString(); break;
        default: ;
        }
    }
}
```

The first 3 cases in the `switch` properly set the arguments array i.e. `_a` but the last 2 cases do not. 

The interesting thing here to note is the code in the first 3 valid cases, it is identical except the function calls e.g.:

```
QString _r = _t->get<...>();    // first 3 variations of get method
if (_a[0]) *reinterpret_cast< QString*>(_a[0]) = std::move(_r);
```

The returning `QString` is assigned to `_r` and then it is move-assigned to `_a[0]` from `_r`.

---

You can get the [project][5] and run a debug session to observe this behavior yourself. I hope this helps.


  [1]: https://stackoverflow.com/revisions/61038922/1
  [2]: https://en.cppreference.com/w/cpp/language/ub
  [3]: https://stackoverflow.com/revisions/61038922/3
  [4]: https://doc.qt.io/qt-5/moc.html#signal-slot-return-types-cannot-be-references
  [5]: https://github.com/iamAzeem/qtquick-test-class-methods
  [6]: https://doc.qt.io/qt-5/qobject.html#Q_INVOKABLE

---
